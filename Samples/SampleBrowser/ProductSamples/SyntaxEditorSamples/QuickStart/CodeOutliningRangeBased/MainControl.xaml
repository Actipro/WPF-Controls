<UserControl x:Class="ActiproSoftware.ProductSamples.SyntaxEditorSamples.QuickStart.CodeOutliningRangeBased.MainControl"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:system="clr-namespace:System;assembly=mscorlib"
	xmlns:shared="http://schemas.actiprosoftware.com/winfx/xaml/shared" 
	xmlns:editor="http://schemas.actiprosoftware.com/winfx/xaml/syntaxeditor" 
	xmlns:editorOutlining="clr-namespace:ActiproSoftware.Windows.Controls.SyntaxEditor.Outlining;assembly=ActiproSoftware.SyntaxEditor.Wpf"
	xmlns:sample="clr-namespace:ActiproSoftware.ProductSamples.SyntaxEditorSamples.QuickStart.CodeOutliningRangeBased"
    >
	<UserControl.Resources>

		<ObjectDataProvider x:Key="OutliningModeObjectDataProvider" MethodName="GetValues" ObjectType="{x:Type system:Enum}">
			<ObjectDataProvider.MethodParameters>
				<x:Type TypeName="editorOutlining:OutliningMode"/>
			</ObjectDataProvider.MethodParameters>
		</ObjectDataProvider>
		
	</UserControl.Resources>
    
	<DockPanel>
		<StackPanel DockPanel.Dock="Top" Margin="20,10" Orientation="Horizontal">
			<Button Click="OnOpenButtonClick">
				<StackPanel Orientation="Horizontal">
					<shared:DynamicImage Width="16" Height="16" Stretch="Uniform" Source="/Images/Icons/Open16.png" />
					<TextBlock Margin="3,0,0,0" Text="Open" VerticalAlignment="Center" />
				</StackPanel>
			</Button>
			<shared:PopupButton Margin="7,0,0,0" DisplayMode="Merged" Content="Outlining" PopupMenuDataContext="{Binding ElementName=editor}">
				<shared:PopupButton.PopupMenu>
					<ContextMenu>
						<MenuItem Command="editor:EditorCommands.CollapseToDefinitions" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.ExpandAllOutlining" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.HideSelection" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.ToggleOutliningExpansion" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.ToggleAllOutliningExpansion" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.StopOutlining" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.StopHidingCurrent" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.StartAutomaticOutlining" CommandTarget="{Binding}" />
						<MenuItem Command="editor:EditorCommands.ApplyDefaultOutliningExpansion" CommandTarget="{Binding}" />
					</ContextMenu>
				</shared:PopupButton.PopupMenu>
			</shared:PopupButton>
			<TextBlock Margin="50,0,0,0" VerticalAlignment="Center" Text="Allowed Mode: " />
			<ComboBox 
				SelectedValue="{Binding ElementName=document, Path=OutliningMode}" 			 
				ItemsSource="{Binding Source={StaticResource OutliningModeObjectDataProvider}}" />
			<TextBlock Margin="22,0,0,0" VerticalAlignment="Center" Text="Active Mode: " />
			<TextBlock VerticalAlignment="Center" Text="{Binding ElementName=document, Path=OutliningManager.(editorOutlining:IOutliningManager.ActiveMode)}" FontWeight="Bold" />
			<CheckBox Margin="50,0,0,0" Content="Margin hover highlights enabled" IsChecked="{Binding ElementName=editor, Path=IsCollapsibleRegionHighlightingEnabled}" VerticalAlignment="Center" />
		</StackPanel>
		
		<!-- SyntaxEditor -->
		<editor:SyntaxEditor x:Name="editor" IsLineNumberMarginVisible="True">
			<editor:EditorDocument x:Name="document" xml:space="preserve">
				<editor:EditorDocument.Language>
					<sample:JavascriptSyntaxLanguage />
				</editor:EditorDocument.Language><![CDATA[/* 

This QuickStart shows a more advanced way to achieve code outlining for 
a language, which is to use a range-based outlining source that is
generated by an IParser in a worker thread.  In this scenario, the
parser scans and provides outlining data for the entire document.
Since a majority of the work is done in a separate thread, there is 
almost no impact to the UI thread.

The benefits of this sort of outlining source are that it doesn't slow
down the main UI thread (even for relatively large documents) when typing,
and allows for complete customization of what text ranges become
outlining nodes.  For example, in this sample we only make outlining
nodes for top-level curly braces, instead of all curly braces.

The drawbacks are that it is slightly more complex than the simpler
token-based outlining source mechanism, and there can be a brief delay
between when typing and when outlining node UI pops into the margin.

Advanced syntax language developers will want to build an IParser to
construct an AST of their document, and use that AST data to create
the appropriate outlining node ranges for their outlining source.
This particular sample doesn't make an AST, but does use an IParser
to scan the document and generate the appropriate outlining node ranges.

*/

var labelString = 'Screen pixel count: ';

function displayScreenPixelCount(screenWidth, screenHeight) {
	/*
		Write a paragraph with the screen's pixel count
	*/
	document.write("<p>" + labelString);

	var pixelCount = product(screenWidth, screenHeight);
	document.write(pixelCount);

	if (pixelCount <= 64000) {
		document.write(" (small)");
	}
	else {
		document.write(" (large)");
	}

	document.write("</p>");
}

function product(x, y) {
	return x * y;
}
]]></editor:EditorDocument>

		</editor:SyntaxEditor>

	</DockPanel>

</UserControl>
