<UserControl x:Class="ActiproSoftware.ProductSamples.SyntaxEditorSamples.QuickStart.GettingStarted03c.MainControl"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:editor="http://schemas.actiprosoftware.com/winfx/xaml/syntaxeditor"
    xmlns:sample="clr-namespace:ActiproSoftware.ProductSamples.SyntaxEditorSamples.QuickStart.GettingStarted03c"
    >

	<!-- SyntaxEditor -->
	<editor:SyntaxEditor x:Name="editor">
		<editor:EditorDocument xml:space="preserve">
			<editor:EditorDocument.Language>
				<sample:SimpleSyntaxLanguage />
			</editor:EditorDocument.Language><![CDATA[/*
	In this sample we've taken an optional route and created a programmatic
	mergable lexer by hand.  The previous steps used a dynamic lexer 
	generated by the Language Designer.  Note that syntax highlighting 
	driven by this new lexer still looks exactly the same to the end user.
	
	Programmatic lexers are faster than dynamic lexers and are an available 
	way to improve performance if your dynamic lexer it not fast enough.
	If your dynamic lexer does perform adequately, then there is no need
	to build a programmatic lexer.
	
	It doesn't matter whether a dynamic or programmatic lexer is used though.
	Either will work fine with all of the subsequent steps where we add
	advanced parsers and functionality.  However since we now have a
	programmatic lexer, we'll use it for the next steps.
*/

function Add(x, y) {
	return x + y;
}

function Increment(x) {
	return (x + 1);
}

function IncrementAndMultiply(x, y) {
	// This function calls another function
	var result;
	result = Increment(x);
	return result * y;
}
]]></editor:EditorDocument>

	</editor:SyntaxEditor>

</UserControl>
